---
title: 数据结构学习（持续更新）
date: 2020-03-03 12:05:54
tags: [数据结构]
categories: [数据结构]
comments: true
---

由于以前学习的基础不扎实还是有部分代码理解不清
已理解的地方会注释

<!--more-->
**

## 先序构建二叉树，按先序、中序、后序输出

**
&表示引用，更改引用值会更改被引用的值；*表示指针，和原来的值独立。
```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_TREE_SIZE 100

typedef struct BiTNode
{
	char data;
	struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

void CreateBiTree(BiTree &T)
{//按先序输入二叉树结点，#表示空树 
	char ch;
	scanf("%c",&ch);
	if(ch=='#')
	{
		T=NULL;
	}else{
	T = (BiTree)malloc(sizeof(BiTNode));
	T->data=ch;
	CreateBiTree(T->lchild);
	CreateBiTree(T->rchild);
	}
}


void PreOrderTravel(BiTree T)
{//先序遍历  根左右
    if(T==NULL) return;			//结束本次循环 
    printf("%c ",T->data);		//正在遍历的结点 
    PreOrderTravel(T->lchild);	//进入左结点 
    PreOrderTravel(T->rchild);	//左结点为空进入右结点 
}
 

void InOrderTravel(BiTree T)
{//中序遍历 左根右
    if(T==NULL)return;
    InOrderTravel(T->lchild);
    printf("%c ",T->data);
    InOrderTravel(T->rchild);
}
 

void TailOrderTravel(BiTree T)
{//后序遍历 左右根
    if(T==NULL) return; 
    TailOrderTravel(T->lchild);
    TailOrderTravel(T->rchild);
    printf("%c ",T->data);
}

int main()
{
	printf("请输入二叉树先序遍历构建二叉树（#代表空）：");
	BiTree T;
	T=(BiTree)malloc(sizeof(BiTNode));
	
	CreateBiTree(T);
	
	printf("先序遍历结果：");
	PreOrderTravel(T);
	printf("\n"); 
	
	printf("中序遍历结果：");
	InOrderTravel(T);
	printf("\n"); 
	
	printf("后序遍历结果：");
	TailOrderTravel(T); 
	printf("\n"); 
}
```
**

## 两个顺序表差集

**

```
#include <stdio.h>
#include <stdlib.h>
#define LIST_INIT_SIZE 100
#define LISTINCREMENT 10
#define OVERFLOW 3

typedef struct
{
	int *elem;
	int length;
	int listsize;
}SqList;

int InitList(SqList &L)
{//初始化顺序表 
	L.elem=(int*)malloc(LIST_INIT_SIZE*sizeof(int));
	if(!L.elem) exit(OVERFLOW);
	L.length=0;
	L.listsize=LIST_INIT_SIZE;
	return 0;
}

void defference(SqList *A,SqList *B,SqList *C)
{//删除相同的元素 
	int i = 0,j = 0,k = 0;
	
	for(i = 0; i < A->length ; i++)
	{
		j = 0;
		
		while(j < B->length && B->elem [j] != A->elem [i]) //找不同的元素 
		{
			j++;
		}
		
		if(j == B->length )//说明找到不同元素 
		{
			C->elem [k] = A->elem [i];
			
			k++;	
		}
	}
	
	C->length = k;
}

void OuputList(SqList L)
{//输出元素 
	int i;
	for(i=0;i<L.length;i++)
	{
		printf("%2d",L.elem[i]);
	}
	printf("\n");
}

int main()
{
	int n,m;
	int i,j;
	SqList La,Lb,Lc;
	InitList(La);
	InitList(Lb);
	InitList(Lc);
	
	printf("请输入La长度:");
	scanf("%d",&n);
	La.length=0;
	printf("请输入La的元素：\n");
	for(i=0;i<n;i++)
	{//输入La 
		scanf("%d",&La.elem[i]);
	}
	La.length=n;
	
	printf("请输入Lb长度:");
	scanf("%d",&m);
	Lb.length=0;
	printf("请输入Lb的元素：\n");
	for(j=0;j<m;j++)
	{//输入Lb 
		scanf("%d",&Lb.elem[j]);
	}
	Lb.length=m;
	
	Lc.length=0;
	
	printf("La:");
	OuputList(La);
	
	printf("Lb:");
	OuputList(Lb);
	
	defference(&La,&Lb,&Lc);
	printf("Lc:");
	OuputList(Lc);
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200215173436545.png)